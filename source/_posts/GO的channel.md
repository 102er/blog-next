---
title: GO的channel
date: 2021-08-19 14:29:21
tags: GO
---

#### 介绍

管道，保证线程安全，用于数据传递或者数据共享，属于先进先出的队列。实现 Channel 的结构并不神秘，本质上就是一个 `mutex` 锁加上一个环状缓存、 一个发送方队列和一个接收方队列

### 通信交互

#### **发送消息**

1. 持有锁
2. 入队，拷贝要发送的数据
   1. 找到是否有正在阻塞的接收方，是则直接发送
   2. 找到是否有空余的缓存，是则存入
   3. 阻塞直到被唤醒
3. 释放锁

#### **接收消息**

1. 上锁
2. 从缓存中出队，拷贝要接收的数据
   1. 如果 Channel 已被关闭，且 Channel 没有数据，立刻返回
   2. 如果存在正在阻塞的发送方，说明缓存已满，从缓存队头取一个数据，再复始一个阻塞的发送方
   3. 否则，检查缓存，如果缓存中仍有数据，则从缓存中读取，读取过程会将队列中的数据拷贝一份到接收方的执行栈中
   4. 没有能接受的数据，阻塞当前的接收方 Goroutine
3. 解锁

### 通道关闭

#### **channel关闭后的读写**

- 关闭后的channel，可以读数据，因为channel中，可能会有缓存数据存在
- 关闭后的channel，如果再写数据，会引起panic异常，可以判断是否channel关闭，防止panic产生
- nil的channel读写都会阻塞，再次close会引起panic

#### 关闭原则

一个常用的使用Go通道的原则是**不要在数据接收方或者在有多个发送者的情况下关闭通道**。 换句话说，我们只应该让一个通道唯一的发送者关闭此通道。

- 情形一：M个接收者和一个发送者。发送者通过关闭用来传输数据的通道来传递发送结束信号
- 情形二：一个接收者和N个发送者，此唯一接收者通过关闭一个额外的信号通道来通知发送者不要在发送数据了
- 情形三：M个接收者和N个发送者。它们中的任何协程都可以让一个中间调解协程帮忙发出停止数据传送的信号
- 情形四：“M个接收者和一个发送者”情形的一个变种：用来传输数据的通道的关闭请求由第三方发出
