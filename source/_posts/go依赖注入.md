---
title: go依赖注入
date: 2021-12-23 23:01:58
tags:	
   - GO
---

在学习go的依赖注入之前，先了解下“依赖注入”和“控制反转”两个东西：

正常情况下，对函数或方法的调用是我们的主动直接行为，在调用某个函数之前我们需要清楚地知道被调函数的名称是什么，参数有哪些类型等等。

所谓的控制反转就是将这种主动行为变成间接的行为，我们不用直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为称作“控制反转”，库和框架能很好的解释控制反转的概念。

依赖注入是实现控制反转的一种方法，如果说控制反转是一种设计思想，那么依赖注入就是这种思想的一种实现，通过注入参数或实例的方式实现控制反转。如果没有特殊说明，我们可以认为依赖注入和控制反转是一个东西。

<!-- more -->

Go的依赖注入框架有两类，一类是通过反射在运行时进行依赖注入，典型代表是 uber 开源的 dig，另外一类是通过 generate 进行代码生成，典型代表是 Google 开源的 wire。

实际项目中我们使用wire实现依赖注入，`wire`是 Google 开源的一个依赖注入工具。它是一个代码生成器，并不是一个框架。我们只需要在一个特殊的`go`文件中告诉`wire`类型之间的依赖关系，它会自动帮我们生成代码，帮助我们创建指定类型的对象，并组装它的依赖。

<!-- more -->

### 基础概念

wire有两个基础概念，构造器provider和injector注入器：

- Provider：是一个普通的函数，这个函数会返回构建依赖关系所需的组件。相当于实例化一个对象。
- injector：也是一个普通函数，我们常常在 `wire.go` 文件中定义 injector 函数签名，然后通过 `wire` 命令自动生成一个完整的函数。

#### provider构造器

provider函数，一般跟着结构体对象定义，**在 wire 中不能存在两个 provider 返回相同的组件类型**

```go
type UserService struct {
}

func NewUserService() *UserService {
   return &UserService{}
}
```

在wire_set.go设置provider set：

```go
import (
   "github.com/102er/apiserver/internal/service"
   "github.com/google/wire"
)

var ProviderSet = wire.NewSet(service.NewUserService)
```

我们可以使用**ProviderSet**，它主要把provider打包成一个集合，我们传给injector只需要传这个集合即可，这样方便我们维护provide。当然，也可以直接把NewUserService()这个函数传给injector的build函数

#### injector注入器

injector函数一般定义在wire.go文件中，通过wire命令自动生成一个完整的函数，wire.go代码如下：

```go
//go:build wireinject
// +build wireinject

// The build tag makes sure the stub is not built in the final build.

package main

import (
	"github.com/102er/apiserver/internal"
	"github.com/102er/apiserver/internal/server"
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
)

//初始化，且会返回一个gin的engine 
//main函数可以调用initApi 拿到 gin.engine 启动服
func initApi() (*gin.Engine, error) {
	panic(wire.Build(internal.ProviderSet, server.NewGinHttpServer))
}
```

- //+build wireinject`与`package main`这两行之间的空行必须要有。
- `+build`其实是 Go 语言的一个特性。类似 C/C++ 的条件编译，在执行`go build`时可传入一些选项，根据这个选项决定某些文件是否编译。`//+build wireinject` 注释确保了这个文件在我们正常编译的时候不会被引用。
- `wire`工具只会处理有`wireinject`的文件，所以我们的`wire.go`文件要加上这个。

上面的代码通过 wire 工具生成：wire_gen.go代码：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
   "github.com/102er/apiserver/internal/server"
   "github.com/102er/apiserver/internal/service"
   "github.com/gin-gonic/gin"
)

// Injectors from wire.go:

func initApi() (*gin.Engine, error) {
   userService := service.NewUserService()
   engine := server.NewGinHttpServer(userService)
   return engine, nil
}
```

main函数如下：

```go
import (
   "fmt"
   v1 "github.com/102er/apiserver/api/v1"
)

func main() {
   reply := v1.HelloReply{Message: "102er"}
   fmt.Println("start api server,", reply.Message)
  //调用的是 wire_gen.go 生成的函数
   srv, err := initApi()
   if err != nil {
      panic(err)
   }
  //启动gin服务
   err = srv.Run()
   if err != nil {
      panic(err)
   }
}
```

### 高级特性

#### 不要使用默认类型

wire 不支持两个提供**两个相同类型**的 provider，所以如果我们使用默认类型如 `int` `string` 等，只要有两个依赖就会导致报错，解决方案是使用类型别名。

#### Option Struct

某个provide函数可能会有很多参数，这时候可以定义option struct，使用 `wire.Strcut` 来构建 Option Strcut 的依赖

#### 返回错误

在 go 中如果遇到错误，我们会在最后一个返回值返回 error，wire 同样也支持返回错误的情况，只需要在 injector 的函数签名中加上 error 返回值即可

#### 清理函数

通常打开文件或者是链接这种需要关闭的资源，这时候 provider 可以返回一个闭包函数 `func()` ，wire 在进行构建的时候，会在报错的时候调用，并且会将所有的**闭包**函数聚合返回。

完整代码示例参数：[102er-apiserver](https://github.com/102er/apiserver)
