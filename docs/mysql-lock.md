## 概述

mysql的并发控制方案：锁机制和多版本并发控制MVCC结合

innoDB通过锁+mvcc的方式实现隔离级别

## 事务

事务是保证用户的数据操作对数据是”安全“的，满足事务的ACID特性。

| 原子性（atomicity）   | 一个事务要么全部执行，要么完全不执行               |
| --------------------- | -------------------------------------------------- |
| 一致性（consistency） | 事务在开始和结束时，应该始终满足一致性约束         |
| 隔离性（isolation）   | 在事务操作时，其他事务的操作不能影响当前的事务操作 |
| 持久性（durability）  | 事务操作的结果是具有持久性                         |

### 事务隔离级别

事务之间如果不是互相隔离的，会出现几个问题：

1. 更新丢失：当多个事务选择同一行，然后基于最初选定的值进行更新该行时，由于每个事务都不知道其他事务存在，就好发生丢失更新问题，最后的更新覆盖了其他事务所做的更新。
2. 脏读：一个事务正在对一条记录进行修改，在这个事务完成并未提交前，这条记录的数据处于不一致状态；这时，另外一个事务也来读取同一条记录，就会造成读到未提交的数据。
3. 不可重复读：同个事务读到不同的数据，主要针对更新操作，导致前后读取的数据内容不一致的情况
4. 幻读：一个事务按照相同的条件读到的数据行数不同，主要针对写和删除操作，导致前后读取的记录数不一致的情况

更新丢失，更主要由应用层面去关注解决，其他三种情况都是数据库读一致性问题，必须由数据库层面提供事务隔离机制来解决。事务的隔离级别定义了事务之间按照什么规则进行隔离，将事务隔离到什么程度，如下表：

| 事务隔离级别  | 脏读 | 不可重复读 | 幻读                                          |
| ------------- | ---- | ---------- | --------------------------------------------- |
| 读未提交      | Y    | Y          | Y                                             |
| 不可重复读 RC | N    | Y          | Y                                             |
| 可重复读 RR   | N    | N          | Y，能避免大部分的幻读，但不能完全禁止幻读现象 |
| 串行化        | N    | N          | N                                             |

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定的程度上”串行化“进行，这显然与”并发“是矛盾的；实际业务场景根据对一致性和事务隔离程度的要求进行评估使用哪种事务，一般都是基于RC和RR进行选择，而mysql innodb引擎默认是RR隔离级别。

不可重复读和幻读有相似性，两者都是读取结果不一致，但是要解决却不一样：

1. 不可重复读：对于RC隔离级别，解决不可重复读只需要加锁；对于RR隔离级别使用MVCC实现可重复读；
2. 幻读：解决幻读必须锁住满足条件的记录以及所有这些记录之间的gap，也就是需要 GAP LOCK；

### RR和RC的区别

- 主从复制，RC不能支持statement格式的bin log
- RR 支持 gap lock(next-key lock)，而RC则没有gap lock，所以RC的并发一般要好于RR；
- RC没间隙锁的存在，一定程度上可以减少锁竞争，死锁和锁超时发生的概率
- 数据一致性的差异，RC每一条select语句都有自己的一致性读read view，每次读取都能读取到已经提交的数据；而RR隔离级别，一致性读的read view是以第一条select语句的运行时，作为当前事务的一致性读snapshot的建立时间点，只能读取到该时间点之前提交的数据。
- 半一致性读.....

## 锁

锁机制保证数据一致性。mysql有三种锁：

1. 行锁：开销大，加锁慢，会出现死锁，粒度小，发生锁冲突概率低，并发度高；
2. 表锁：开销小，加锁快，不会出现死锁，粒度大，发生锁冲突概率高，并发度极低；
3. 页锁：介于以上两个锁之间，会出现死锁，并发度一般；

2PL加锁原则（two-phase locking 二阶段锁）：加锁阶段只加锁，解锁阶段只解锁，不会彼此交叉。

### 锁类型

innoDB实现了以下2种类型的行锁：

1. 共享锁（S）： 读读操作可以并行，不互斥；允许多个事务读同一行，阻止其他事务获得相同的数据集的排他锁。
2. 排他锁（X）：读写，写写操作不可以并行，互斥；允许获得排它锁的事务更新数据，但是阻止其他事务获得相同数据集的共享锁和排他锁。

这两种锁类型在一些场景下会有瓶颈：

**场景1：读写场景并发瓶颈**

S锁和X锁提升了读-读的并发场景性能，但是对于写入的过程，读任务还是会被阻塞，读-写操作性能还是存在瓶颈，所以在这个场景上mysql引入了MVCC并发控制机制。

MVCC侧重读写并发的改善机制，主要用于避免写操作堵塞读操作的并发问题，通过使用数据的多个版本保证并发读写不冲突的一种机制。涉及两个概念： 

1. 当前读（current read）：读取的是最新版本，会加上锁，保证其他事务不会再修改这条记录，delete/update/select for update 等都是current read；
2. 快照读（snapshot read）：又称··一致性读，使用mvcc机制读取undo中已经提交的数据，读取的是数据的可见版本，是数据的历史镜像，这个过程不加锁，普通的select都是snapshot read；

```PlainText
undo log是事务日志之一，用于事务回滚和多版本控制MVCC的日志
1、在事务没有提交之前，MySQL会先记录更新前的数据到undo log日志文件里面，当事务回滚时或者数据库崩溃时，可以利用undo进行回退；
2、当读取的某一行被其他事务锁定时，可以从undo log中分析该行记录以前的数据版本是怎么样的，从而让用户能够读取事务操作之前的数据【快照读】；
```

**场景2：行锁和表锁冲突**

行锁和表锁冲突判断，需要引入意向锁来协调冲突。

事务A锁住了表中某一行，加了行锁S，即这行只读不能写 -> 之后事务B申请了整个表的写锁，那么理论上它可以修改任意一行数据，包括共享锁S锁定的那个记录，这种情况下和事务A持有的的行锁是冲突的。

这个场景下，需要通过意向锁来协调这个冲突：

1. 事务A必须先申请表的意向共享锁，成功后申请一把行锁；
2. 事务B申请排它锁，发现表上已经有意向共享锁，说明表中的某些行已经被共享锁定了，事务B申请写锁的操作就会被阻塞；

innodb提供了两个表级意向锁：

1. 意向共享锁（IS）：表示事务准备给数据行加入共享锁S，一个数据行加共享锁S前必须先获得该表的IS锁；
2. 意向排他锁（IX）：表示事务准备给数据行加入排它锁X，一个事务在一个数据行加排它锁X前必须取得该表的IX锁；

4种锁之间的兼容情况列表：

| 请求锁是否兼容当前锁 | X    | IX   | S    | IS   |
| -------------------- | ---- | ---- | ---- | ---- |
| X                    | 冲突 | 冲突 | 冲突 | 冲突 |
| IX                   | 冲突 | 兼容 | 冲突 | 兼容 |
| S                    | 冲突 | 冲突 | 兼容 | 兼容 |
| IS                   | 冲突 | 兼容 | 兼容 | 兼容 |

意向锁之间是互相兼容的，S锁和X锁是互相排斥的，S锁之间是互相兼容的

如果一个事务请求的锁与当前的锁兼容，innodb就将请求的锁授予该事务；反之，如果两者不兼容，该事务就需要等待锁释放；

如果锁不兼容，通常会产生阻塞，相互等待就会有死锁的情况发生；

### innoDB行锁

innoDB行锁是通过给索引项加锁实现的，如果没有索引，innoDB就会通过隐藏的聚簇索引来对记录加锁。

如果不通过索引条件来检索数据，那么innodb将对表中所有数据加锁，所以在业务中需要特别注意这一特性，它会影响并发的性能。

innodb在给索引加X锁的同时也会给聚簇索引加X锁，其目的是为了避免操作不同索引导致的更新冲突。

innodb支持三种行锁方式：

1. 行锁（record lock）：对索引项进行加锁，即锁定一行记录；
2. 间隙锁（gap lock）：对索引项之间的间隙，对第一条记录前的间隙或者最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身；（RR级别才有间隙锁）
3. Next-key lock：行锁+间隙锁的组合，锁定一个范围的记录并包含记录本身，当innodb扫描索引记录的时候，会对选中的索引记录加上行锁，在对索引记录两边的间隙加上间隙锁，如果一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的。(RR隔离级别默认的锁)

不同索引，产生间隙锁条件不一样：

1. 唯一索引
   1. 指定某一条记录的查询，如果记录存在只使用记录锁，不会产生间隙锁，如果记录不存在，则会产生记录锁和间隙锁。
   2. 按照某一范围检索数据，会产生间隙锁。
2. 普通索引
   1. 在普通索引列上，**不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；**
   2. 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序

innodb的加锁

- 加锁的基本单位是临键锁next-key lock。next-key lock是前开后闭区间。
- 索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
- 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。