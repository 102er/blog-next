---
title: go之xx问
date: 2021-08-09 14:29:55
categories:
    - GO
tags: GO
---

#### `T`和`*T`的调用关系

在Go语言中，为了方便，对于一个非指针和非接口定义类型`T`，

- 一个`T`类型的值可以调用为`*T`类型声明的方法，但是仅当此`T`的值是可寻址的情况下。 编译器在调用指针属主方法前，会自动取此`T`值的地址。 因为不是任何`T`值都是可寻址的，所以并非任何`T`值都能够调用为类型`*T`声明的方法。 这种便利只是一个语法糖，而不是一种固有的规则。（常量不可寻址）
- 一个`*T`类型的值可以调用为类型`T`声明的方法。 这是因为解引用指针总是合法的。 这种便利不仅仅是一个语法糖，它也是一种固有的规则。

所以很合理的， `*T`的方法集总是`T`方法集的超集，但反之不然。

事实上，你可以认为对于每一个为类型`T`声明的方法，编译器都会为类型`*T`自动隐式声明一个同名和同签名的方法。

<!-- more -->

#### for和range区别

range 在迭代过程中返回的是迭代值的拷贝，如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样。但是如果迭代的元素内存占用较高，例如一个包含很多属性的 struct 结构体，那么 for 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 for，如果使用 range，建议只迭代下标，通过下标访问迭代值，这种使用方式和 for 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。

#### 数组和切片区别

数组是不可变的数据类型，线程安全

切片是动态可变的数据结构，包含长度，容量以及指向数组的应用，线程不安全

#### rune数据类型

rune是Go语言中一种特殊的数据类型,它是int32的别名,几乎在所有方面等同于int32,用于区分字符值和整数值。

补充：golang中的字符有两种，uint8（byte）代表ASCII的一个字符，rune代表一个utf-8字符。

理解：当需要处理中文、日文或者其他复合字符时，则需要用到rune类型，rune实际是一个int32.

#### init函数

- 不同包的 `init()`执行顺序，按照 `导入包的依赖关系` 决定
- `init()` 不能被其他函数调用，而自动 `在main函数执行前` 被调用
- 执行顺序：import –> const –> var –> init() –> main()

#### make和new的区别

- new可以初始化所有类型，为类型申请一块内存空间并返回一个指针
- make只能用于map ，channel，slice初始化，返回的是类型引用

#### 什么是协程泄露(Goroutine Leak)？

go协程正常结束后，会被gc回收，但是如果一些操作不当，就会引起协程一直处于阻塞状态或者永远运行，这种情况就是协程泄漏了，他会一直消耗资源，直到系统奔溃。泄漏的场景：

- Goroutine 内正在进行 channel/mutex 等读写操作，但由于逻辑问题，某些情况下会被一直阻塞。
- Goroutine 内的业务逻辑进入死循环，资源一直无法释放。
- Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。

检测工具：uber-go/goleak

#### 赋值是原子操作吗？

不是原子操作，会有并发安全问题。设计struct赋值的数据类型 都是并发不安全的 比如slice map等

#### `time.Sleep(d)`和`<-time.After(d)`有何区别？

两者都会将当前的goroutine执行暂停一段时间。 区别在于`time.Sleep(d)`函数调用将使当前的协程进入睡眠子状态，但是当前协程的[（主）状态](https://gfw.go101.org/article/control-flows-more.html#states-of-goroutine)依然为运行状态； 而通道接收`<-time.After(d)`操作将使当前协程进入阻塞状态。

#### 哪些类型不支持比较？

下列类型不支持比较：映射（map、切片、函数、包含不可比较字段的结构体类型、元素类型为不可比较类型的数组类型

不支持比较的类型不能用做映射类型的键值类型。请注意：

- 尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的`nil`标识符比较。
- 如果两个接口值的动态类型相同且不可比较，那么在运行时[比较这两个接口的值](https://gfw.go101.org/article/interface.html#comparison)会产生一个恐慌。

#### 为什么两个`nil`值有时候会不相等？

一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用`nil`来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。

当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。

#### 哪些值可以被取地址，哪些值不可以被取地址？

以下的值是不可以寻址的：

- 字符串的字节元素
- 映射元素
- 接口值的动态值（类型断言的结果）
- 常量（包括有名常量和字面量）
- 声明的包级别函数
- 方法（用做函数值）
- 中间结果值
  - 函数调用
  - 显式值转换
  - 各种操作，不包含指针解引用（dereference）操作，但是包含：
    - 通道接收操作
    - 子字符串操作
    - 子切片操作
    - 加法、减法、乘法、以及除法等等。

以下的值是可寻址的，因此可以被取地址：变量

可寻址的结构体的字段

- 可寻址的数组的元素
- 任意切片的元素（无论是可寻址切片或不可寻址切片）
- 指针解引用（dereference）操作

#### 为什么映射元素不可被取地址？

在Go中，映射的设计保证一个映射值在内存允许的情况下可以加入任意个条目。 另外为了防止一个映射中为其条目开辟的内存段支离破碎，官方标准编译器使用了哈希表来实现映射。 并且为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段。 因此，一个映射值随着其中的条目数量逐渐增加时，其维护的连续的内存段需要不断重新开辟来增容，并把原来内存段上的条目全部复制到新开辟的内存段上。 另外，即使一个映射值维护的内存段没有增容，某些哈希表实现也可能在当前内存段中移动其中的条目。 总之，映射中的元素的地址会因为各种原因而改变。 如果映射元素可以被取地址，则Go运行时（runtime）必须在元素地址改变的时候修改所有存储了元素地址的指针值。 这极大得增加了Go编译器和运行时的实现难度，并且严重影响了程序运行效率。 因此，目前，Go中禁止取映射元素的地址。

映射元素不可被取地址的另一个原因是表达式`aMap[key]`可能返回一个存储于`aMap`中的元素，也可能返回一个不存储于其中的元素零值。 这意味着表达式`aMap[key]`在`(&aMap[key]).Modify()`调用执行之后可能仍然被估值为元素零值。 这将使很多人感到困惑，因此在Go中禁止取映射元素的地址。

#### 函数返回局部变量的指针是否安全？

是的，在Go中这是绝对安全的。

支持栈的Go编译器将会对每个局部变量进行逃逸分析。 对于官方标准编译器来说，如果一个值可以在编译时刻被断定它在运行时刻仅会在一个协程中被使用，则此值将被开辟在（此协程的）栈上；否则此值将被开辟在堆上。
